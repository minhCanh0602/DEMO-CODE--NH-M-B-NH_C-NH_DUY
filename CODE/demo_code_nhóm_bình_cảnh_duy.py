# -*- coding: utf-8 -*-
"""DEMO CODE- NHÓM BÌNH_CẢNH_DUY

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G1ftUfffruUnn-DImopAdBzZkga9oDDq
"""

# import các thư viện cần dùng
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn import metrics
from sklearn.metrics import roc_curve
from sklearn.metrics import recall_score, confusion_matrix, precision_score
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.ensemble import AdaBoostClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score, accuracy_score, classification_report
from sklearn.tree import DecisionTreeClassifier
from sklearn import model_selection
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

# tải dữ liệu
from google.colab import files
uploaded = files.upload()

import io
df = pd.read_csv(io.BytesIO(uploaded['dataset_train.csv']))

# In số lượng hàng và cột trong khung dữ liệu
print("{} rows and {} columns".format(df.shape[0], df.shape[1]))

#Hiển thị tên của từng cột trong khung dữ liệu
print(df.columns)

# In 10 hàng đầu tiên của khung dữ liệu
print("\n[FIRST 10 ROWS PREVIEW]")
df.head(10)

#Số phần tử uniqe trong mỗi cột
unique = df.nunique()
unique.to_frame().T

# thống kê dữ liệu
df.iloc[:, :-1].describe().T.sort_values(by='std', ascending = False)\
                          .style.background_gradient(cmap="Greens")\
                          .bar(subset=["max"], color='#F8766D')\
                          .bar(subset=["mean"], color='#00BFC4')
# mô tả tệp dữ liệu (cột chứa giá trị là số) với:
#count: tổng số các bản ghi khác null trong dữ liệu
#min, max: giá trị lớn nhất nhỏ nhất trong dải dữ liệu
#mean: giá trị trung bình
#std: Độ lệch chuẩn của cột
#25%: Phần tư thứ nhất (phần trăm thứ 25) của cột
#50%: Trung vị (phân vị thứ 50) của cột
#75%: Phần tư thứ ba (phần trăm thứ 75) của cột

# Dataset information
df.info()

# Hiển thị số lượng số và không phải số trong khung dữ liệu
print("Number of numerical columns: {}".format(df.select_dtypes(include=np.number).shape[1]))
print("Number of non-numerical columns: {}".format(df.select_dtypes(exclude=np.number).shape[1]))

# Tìm kiếm các giá trị còn thiếu trong khung dữ liệu
print(" Total missing values is {}".format(df.isnull().sum().sum()))
print(" Missing values by column is as follows:")
df.isnull().sum()

#kiểm tra giá trị trùng lặp
df.duplicated().sum()

#Kiểm tra ngoại lệ
#Các tính năng số và phân loại riêng biệt
num_cols = pd.DataFrame (df, columns= ['no_of_adults', 'no_of_children', 'no_of_weekend_nights', 'no_of_week_nights', 'required_car_parking_space', 
                                       'lead_time', 'arrival_year', 'arrival_date', 'repeated_guest', 'no_of_previous_cancellations', 'no_of_previous_bookings_not_canceled',
                                       'avg_price_per_room', 'no_of_special_requests'])
cat_cols = pd.DataFrame (df, columns= ['type_of_meal_plan', 'room_type_reserved', 'market_segment_type'])

#Tách các tính năng số và phân loại thành các danh sách khác nhau
numerical_columns = list(df.loc[:,['no_of_adults', 'no_of_children', 'no_of_weekend_nights', 'no_of_week_nights', 'required_car_parking_space', 
                                   'lead_time', 'arrival_year', 'arrival_date', 'repeated_guest', 'no_of_previous_cancellations', 'no_of_previous_bookings_not_canceled', 
                                   'avg_price_per_room', 'no_of_special_requests']])
categorical_columns = list(df.loc[:,['type_of_meal_plan', 'room_type_reserved', 'market_segment_type']])

#Trực quan hóa các tính năng số bằng boxplots
sns.set_style('darkgrid')
def boxplots_custom(dataset, columns_list, rows, cols, suptitle):
    fig, axs = plt.subplots(rows, cols, sharey=True, figsize=(15,7))
    fig.suptitle(suptitle, y=1, size=25)
    axs = axs.flatten()
    for i, data in enumerate(columns_list):
        sns.boxplot(data=dataset[data], orient='h', color ='#b7e7dd', ax=axs[i])
        axs[i].set_title(data + ', skewness is: '+str(round(dataset[data].skew(axis = 0, skipna = True), 2)))
        
boxplots_custom(dataset=df, columns_list=num_cols, rows=5, cols=3, suptitle='Boxplots cho mỗi biến')
plt.tight_layout()

#Tính toán ngoại lệ 
#Tính toán IQR cho mỗi cột trong tập dữ liệu (bỏ)
Q1 = num_cols.quantile(0.25)
Q3 = num_cols.quantile(0.75)
IQR = Q3 - Q1

# Xác định các ngoại lệ bằng phương pháp IQR
outliers = ((num_cols < (Q1 - 1.5 * IQR)) | (num_cols > (Q3 + 1.5 * IQR)))

# Đếm số lượng ngoại lệ cho mỗi biến
num_outliers = outliers.sum()

# Number of outliers for each variable
num_outliers.to_frame().T

from typing import Tuple
from sklearn.base import BaseEstimator, TransformerMixin


def find_boxplot_boundaries(
    col: pd.Series, whisker_coeff: int = 1
) -> Tuple[int, int]:
    """Findx minimum and maximum in boxplot.

    Args:
        col: a pandas serires of input.
        whisker_coeff: whisker coefficient in box plot
    """
    Q1 = col.quantile(0.25)
    Q3 = col.quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - whisker_coeff * IQR
    upper = Q3 + whisker_coeff * IQR
    return lower, upper


class BoxplotOutlierClipper(BaseEstimator, TransformerMixin):
    def __init__(self, whisker_coeff: int = 1.5):
        self.whisker = whisker_coeff
        self.lower = None
        self.upper = None

    def fit(self, X: pd.Series):
        self.lower, self.upper = find_boxplot_boundaries(X, self.whisker)
        return self

    def transform(self, X):
        return X.clip(self.lower, self.upper)

#xử lý ngoại lệ thuộc tính no_of_weekend_nights
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
df[["no_of_weekend_nights"]].hist(bins=50, ax=axes[0]);
df[["no_of_weekend_nights"]].boxplot(ax=axes[1], vert=False);

clipped_total_rooms = BoxplotOutlierClipper().fit_transform(df["no_of_weekend_nights"])

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
clipped_total_rooms.hist(bins=50, ax=axes[0])
clipped_total_rooms.to_frame().boxplot(ax=axes[1], vert=False);

#xử lý ngoại lệ thuộc tính no_of_week_nights
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
df[["no_of_week_nights"]].hist(bins=50, ax=axes[0]);
df[["no_of_week_nights"]].boxplot(ax=axes[1], vert=False);

clipped_total_rooms = BoxplotOutlierClipper().fit_transform(df["no_of_week_nights"])

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
clipped_total_rooms.hist(bins=50, ax=axes[0])
clipped_total_rooms.to_frame().boxplot(ax=axes[1], vert=False);

#xử lý ngoại lệ thuộc tính lead_time
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
df[["lead_time"]].hist(bins=50, ax=axes[0]);
df[["lead_time"]].boxplot(ax=axes[1], vert=False);

clipped_total_rooms = BoxplotOutlierClipper().fit_transform(df["lead_time"])

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
clipped_total_rooms.hist(bins=50, ax=axes[0])
clipped_total_rooms.to_frame().boxplot(ax=axes[1], vert=False);

#xử lý ngoại lệ thuộc tính no_of_previous_bookings_not_canceled
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
df[["no_of_previous_bookings_not_canceled"]].hist(bins=50, ax=axes[0]);
df[["no_of_previous_bookings_not_canceled"]].boxplot(ax=axes[1], vert=False);

clipped_total_rooms = BoxplotOutlierClipper().fit_transform(df["no_of_previous_bookings_not_canceled"])

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
clipped_total_rooms.hist(bins=50, ax=axes[0])
clipped_total_rooms.to_frame().boxplot(ax=axes[1], vert=False);

#xử lý ngoại lệ thuộc tính 'no_of_special_requests'
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
df[["no_of_special_requests"]].hist(bins=50, ax=axes[0]);
df[["no_of_special_requests"]].boxplot(ax=axes[1], vert=False);

clipped_total_rooms = BoxplotOutlierClipper().fit_transform(df["no_of_special_requests"])

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
clipped_total_rooms.hist(bins=50, ax=axes[0])
clipped_total_rooms.to_frame().boxplot(ax=axes[1], vert=False);

#xử lý ngoại lệ thuộc tính 'avg_price_per_room'
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
df[["avg_price_per_room"]].hist(bins=50, ax=axes[0]);
df[["avg_price_per_room"]].boxplot(ax=axes[1], vert=False);

from typing import Tuple
from sklearn.base import BaseEstimator, TransformerMixin


def find_boxplot_boundaries(
    col: pd.Series, whisker_coeff: float = 1.5
) -> Tuple[float, float]:
    """Findx minimum and maximum in boxplot.

    Args:
        col: a pandas serires of input.
        whisker_coeff: whisker coefficient in box plot
    """
    Q1 = col.quantile(0.25)
    Q3 = col.quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - whisker_coeff * IQR
    upper = Q3 + whisker_coeff * IQR
    return lower, upper


class BoxplotOutlierClipper(BaseEstimator, TransformerMixin):
    def __init__(self, whisker_coeff: float = 1.5):
        self.whisker = whisker_coeff
        self.lower = None
        self.upper = None

    def fit(self, X: pd.Series):
        self.lower, self.upper = find_boxplot_boundaries(X, self.whisker)
        return self

    def transform(self, X):
        return X.clip(self.lower, self.upper)

clipped_total_rooms = BoxplotOutlierClipper().fit_transform(df["avg_price_per_room"])

fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 5))
clipped_total_rooms.hist(bins=50, ax=axes[0])
clipped_total_rooms.to_frame().boxplot(ax=axes[1], vert=False);

df.head()

#EDA
#EDA
#Phân phối dữ liệu liên tục và phân loại
TARGET = 'booking_status'
FEATURES = [col for col in df.columns if col not in ['df', TARGET]]

cat_features = [col for col in FEATURES if df[col].nunique() < 25]
cont_features = [col for col in FEATURES if df[col].nunique() >= 25]

num_cat_features = len(cat_features)
num_cont_features = len(cont_features)

print(f"Tổng số tính năng ngoại trừ mục tiêu: {len(FEATURES)}")
print(f"\033[92mSố lượng tính năng phân loại (<25 Giá trị duy nhất): {num_cat_features}")
print(f"\033[96mSố lượng các tính năng liên tục: {num_cont_features}")

# Define labels and colors for the pie chart
labels = ['Phân loại (<25 Giá trị duy nhất)', 'Continuous']
colors = ['#9eb5ba', '#714ad4']

plt.pie([num_cat_features, num_cont_features], 
        labels=labels,
        colors=colors,
        textprops={'fontsize': 13},
        autopct='%1.1f%%')

# Add a title to the plot
plt.title('Phân phối các tính năng phân loại và liên tục', fontsize=16)

# Show the plot
plt.show()

# Đếm số lần xuất hiện của từng giá trị trong cột 'booking_status'
value_counts = df['booking_status'].value_counts()

# Xác định các chuỗi nhãn bằng f-strings
label = [f'{"Not_Canceled" if i==0 else "Canceled" } cost' for i in range(len(value_counts))]

# Xác định màu sắc 
colors = ['#4d9b68', '#538e8a', '#468e71', '#59ae8c']

# Tạo biểu đồ hình tròn với các giá trị phần trăm được định dạng bằng dấu % và tách các lát
fig, ax = plt.subplots()
wedges, texts, autotexts = ax.pie(value_counts.values, autopct='%0.1f%%', explode=[0.1, 0.1], shadow=True, labels=label, colors=colors)

# Thêm số lượng theo tỷ lệ phần trăm
for i, autotext in enumerate(autotexts):
    count = value_counts[i]
    autotext.set_text(f'{autotext.get_text()} ({count})')
    autotext.set_y(autotext.get_position()[1]-0.1)

# Set the title of the pie chart
ax.set_title('Cân bằng hay Mất cân bằng?')

# Show the pie chart
plt.show()

pr = df.groupby(['booking_status'])
target = pr.describe(percentiles = [0.25, 0.5, 0.75])[numerical_columns]
target.style.background_gradient(cmap='Greens')

# Number of Adults
print(f'\033[92m')
print(df['no_of_adults'].value_counts())
ax1 = df['no_of_adults'].value_counts() \
    .plot(kind="bar", title="no_of_adults")
ax1.set_xlabel("no_of_adults")
ax1.set_ylabel("Counts")
plt.show()

# no_of_children	
print(f'\033[92m')
print(df['no_of_children'].value_counts())
ax1 = df['no_of_children'].value_counts() \
    .plot(kind="bar", title="no_of_children")
ax1.set_xlabel("no_of_children")
ax1.set_ylabel("Counts")
plt.show()

# no_of_weekend_nights	
print(f'\033[92m')
print(df['no_of_weekend_nights'].value_counts())
ax1 = df['no_of_weekend_nights'].value_counts() \
    .plot(kind="bar", title="no_of_weekend_nights")
ax1.set_xlabel("no_of_weekend_nights")
ax1.set_ylabel("Counts")
plt.show()

# no_of_week_nights	
print(f'\033[92m')
print(df['no_of_week_nights'].value_counts())
ax1 = df['no_of_week_nights'].value_counts() \
    .plot(kind="bar", title="no_of_week_nights")
ax1.set_xlabel("no_of_week_nights")
ax1.set_ylabel("Counts")
plt.show()

# type_of_meal_plan
print(f'\033[92m')
print(df['type_of_meal_plan'].value_counts())
ax1 = df['type_of_meal_plan'].value_counts() \
    .plot(kind="bar", title="type_of_meal_plan")
ax1.set_xlabel("type_of_meal_plan")
ax1.set_ylabel("Counts")
plt.show()

# required_car_parking_space
print(f'\033[92m')
print(df['required_car_parking_space'].value_counts())
ax1 = df['required_car_parking_space'].value_counts() \
    .plot(kind="bar", title="required_car_parking_space")
ax1.set_xlabel("required_car_parking_space")
ax1.set_ylabel("Counts")
plt.show()

# room_type_reserved
print(f'\033[92m')
print(df['room_type_reserved'].value_counts())
ax1 = df['room_type_reserved'].value_counts() \
    .plot(kind="bar", title="room_type_reserved")
ax1.set_xlabel("room_type_reserved")
ax1.set_ylabel("Counts")
plt.show()

#lead_time
print(f'\033[92m')
print(df['lead_time'].value_counts())
ax1 = df['lead_time'].value_counts() \
    .plot(kind="bar", title="lead_time")
ax1.set_xlabel("lead_time")
ax1.set_ylabel("Counts")
plt.show()

#arrival_year
print(f'\033[92m')
print(df['arrival_year'].value_counts())
ax1 = df['arrival_year'].value_counts() \
    .plot(kind="bar", title="arrival_year")
ax1.set_xlabel("arrival_year")
ax1.set_ylabel("Counts")
plt.show()

#arrival_month
print(f'\033[92m')
print(df['arrival_month'].value_counts())
ax1 = df['arrival_month'].value_counts() \
    .plot(kind="bar", title="arrival_month")
ax1.set_xlabel("arrival_month")
ax1.set_ylabel("Counts")
plt.show()

#arrival_date
print(f'\033[92m')
print(df['arrival_date'].value_counts())
ax1 = df['arrival_date'].value_counts() \
    .plot(kind="bar", title="arrival_date")
ax1.set_xlabel("arrival_date")
ax1.set_ylabel("Counts")
plt.show()

#market_segment_type
print(f'\033[92m')
print(df['market_segment_type'].value_counts())
ax1 = df['market_segment_type'].value_counts() \
    .plot(kind="bar", title="market_segment_type")
ax1.set_xlabel("market_segment_type")
ax1.set_ylabel("Counts")
plt.show()

#repeated_guest
print(f'\033[92m')
print(df['repeated_guest'].value_counts())
ax1 = df['repeated_guest'].value_counts() \
    .plot(kind="bar", title="repeated_guest")
ax1.set_xlabel("repeated_guest")
ax1.set_ylabel("Counts")
plt.show()

#no_of_previous_cancellations
print(f'\033[92m')
print(df['no_of_previous_cancellations'].value_counts())
ax1 = df['no_of_previous_cancellations'].value_counts() \
    .plot(kind="bar", title="no_of_previous_cancellations")
ax1.set_xlabel("no_of_previous_cancellations")
ax1.set_ylabel("Counts")
plt.show()

#no_of_previous_bookings_not_canceled
print(f'\033[92m')
print(df['no_of_previous_bookings_not_canceled'].value_counts())
ax1 = df['no_of_previous_bookings_not_canceled'].value_counts() \
    .plot(kind="bar", title="no_of_previous_bookings_not_canceled")
ax1.set_xlabel("no_of_previous_bookings_not_canceled")
ax1.set_ylabel("Counts")
plt.show()

#avg_price_per_room
print(f'\033[92m')
print(df['avg_price_per_room'].value_counts())
ax1 = df['avg_price_per_room'].value_counts() \
    .plot(kind="bar", title="avg_price_per_room")
ax1.set_xlabel("avg_price_per_room")
ax1.set_ylabel("Counts")
plt.show()

#no_of_special_requests
print(f'\033[92m')
print(df['no_of_special_requests'].value_counts())
ax1 = df['no_of_special_requests'].value_counts() \
    .plot(kind="bar", title="no_of_special_requests")
ax1.set_xlabel("no_of_special_requests")
ax1.set_ylabel("Counts")
plt.show()

#booking_status
print(f'\033[92m')
print(df['booking_status'].value_counts())
ax1 = df['booking_status'].value_counts() \
    .plot(kind="bar", title="booking_status")
ax1.set_xlabel("booking_status")
ax1.set_ylabel("Counts")
plt.show()

# phân tích đa biến
average_price_status = df.groupby('booking_status')['avg_price_per_room'].mean().reset_index()
sns.barplot(data=average_price_status, x="booking_status", y="avg_price_per_room")
# => giá cao thì tỉ lệ hủy phòng càng nhiều

g = sns.boxplot(df, x='booking_status', y="lead_time")
# => lead_time càng cao thì hủy càng cao

g = sns.catplot(df, x="no_of_special_requests", col='booking_status', kind='count')
#=> Nếu no_of_special_requests nhiều hơn 2, booking_status sẽ không bị hủy

g = sns.catplot(df, x="market_segment_type", col='booking_status', kind='count')
#=> nếu market_segment_type là Complementary thì sẽ không hủy

g = sns.catplot(df, x="no_of_previous_cancellations", col='booking_status', kind='count')
#=> hầu hết các khách hàng hủy đặt phòng của họ sẽ không có đặt phòng khác trong tương lai

g = sns.boxplot(df, y="no_of_weekend_nights", x='booking_status')
#=> hầu hết Hủy đặt phòng là từ số lượng Đêm cuối tuần cao

g = sns.catplot(df, x="type_of_meal_plan", col='booking_status', kind='count')
#=> type_of_meal_plan không ảnh hưởng đến hủy phòng

g = sns.catplot(df, x='arrival_year', y="arrival_month", hue='booking_status', kind='violin')
#=> Tháng 7-8/2017 tỷ lệ hủy cao hơn trong khi đầu năm 2018 tỷ lệ hủy thấp hơn

# Replace values that say "Not_Canceled" in the "booking_status" column with 0, and values that say "Canceled" with 1
df["booking_status"].replace("Not_Canceled", 0, inplace=True)
df["booking_status"].replace("Canceled", 1, inplace=True)
print("- Replaced values that say 'Not_Canceled' in the 'booking_status' column with 0, and values that say 'Canceled' with 1")

plt.figure(figsize=(10,10))
sns.heatmap(df.corr(method='spearman'), annot=True, fmt='.0%')
plt.show()

#tương quan
plt.figure (figsize = (12, 7), dpi = 100)
heatmap = sns.heatmap (df.corr()[['booking_status']].sort_values (by = 'booking_status', ascending = False), vmin = -1, vmax = 1, annot = True, cmap = 'GnBu')
heatmap.set_title ('Các tính năng tương quan với booking_status', fontdict = {'fontsize':12}, pad = 18);

print("- Replaced values that say 'Not_Canceled' in the 'booking_status' column with 0, and values that say 'Canceled' with 1")

# Replace values that say "Not selected" in the "type_of_meal_plan" column with 0
df["type_of_meal_plan"].replace("Not Selected", 0, inplace=True)
print("- Replaced values that say 'Not selected' in the 'type_of_meal_plan' column with 0")

# Replace values that say "Meal Plan 1" in the "type_of_meal_plan" column with 1
df["type_of_meal_plan"].replace("Meal Plan 1", 1, inplace=True)
print("- Replaced values that say 'Meal Plan 1' in the 'type_of_meal_plan' column with 1")

# Replace values that say "Meal Plan 2" in the "type_of_meal_plan" column with 2
df["type_of_meal_plan"].replace("Meal Plan 2", 2, inplace=True)
print("- Replaced values that say 'Meal Plan 2' in the 'type_of_meal_plan' column with 2")

# Replace values that say "Meal Plan 3" in the "type_of_meal_plan" column with 3
df["type_of_meal_plan"].replace("Meal Plan 3", 3, inplace=True)
print("- Replaced values that say 'Meal Plan 3' in the 'type_of_meal_plan' column with 3")

# Replace values that say "Room_Type 1" in the "room_type_reserved" column with 1
df["room_type_reserved"].replace("Room_Type 1", 1, inplace=True)
print("- Replaced values that say 'Room_Type 1' in the 'room_type_reserved' column with 1")

# Replace values that say "Room_Type 2" in the "room_type_reserved" column with 2
df["room_type_reserved"].replace("Room_Type 2", 2, inplace=True)
print("- Replaced values that say 'Room_Type 2' in the 'room_type_reserved' column with 2")

# Replace values that say "Room_Type 3" in the "room_type_reserved" column with 3
df["room_type_reserved"].replace("Room_Type 3", 3, inplace=True)
print("- Replaced values that say 'Room_Type 3' in the 'room_type_reserved' column with 3")

# Replace values that say "Room_Type 4" in the "room_type_reserved" column with 4
df["room_type_reserved"].replace("Room_Type 4", 4, inplace=True)
print("- Replaced values that say 'Room_Type 4' in the 'room_type_reserved' column with 4")

# Replace values that say "Room_Type 5" in the "room_type_reserved" column with 5
df["room_type_reserved"].replace("Room_Type 5", 5, inplace=True)
print("- Replaced values that say 'Room_Type 5' in the 'room_type_reserved' column with 5")

# Replace values that say "Room_Type 6" in the "room_type_reserved" column with 6
df["room_type_reserved"].replace("Room_Type 6", 6, inplace=True)
print("- Replaced values that say 'Room_Type 6' in the 'room_type_reserved' column with 6")

# Replace values that say "Room_Type 7" in the "room_type_reserved" column with 7
df["room_type_reserved"].replace("Room_Type 7", 7, inplace=True)
print("- Replaced values that say 'Room_Type 7' in the 'room_type_reserved' column with 7")

# Replace values that say "Offline" in the "market_segment_type" column with 0
df["market_segment_type"].replace("Offline", 0, inplace=True)
print("- Replaced values that say 'Offline' in the 'market_segment_type' column with 0")
# Replace values that say "Online" in the "market_segment_type column with 1
df["market_segment_type"].replace("Online", 1, inplace=True)
print("- Replaced values that say 'Online' in the 'market_segment_type' column with 1")
# Replace values that say "Corporate" in the "market_segment_type" column with 2
df["market_segment_type"].replace("Corporate", 2, inplace=True)
print("- Replaced values that say 'Corporate' in the 'market_segment_type' column with 2")
# Replace values that say "Aviation" in the "market_segment_type" column with 3
df["market_segment_type"].replace("Aviation", 3, inplace=True)
print("- Replaced values that say 'Aviation' in the 'market_segment_type' column with 3")
# Replace values that say "Complementary" in the "market_segment_type" column with 3
df["market_segment_type"].replace("Complementary", 4, inplace=True)
print("- Replaced values that say 'Complementary' in the 'market_segment_type' column with 4")

#Hiển thị số lượng cột số và không phải số trong khung dữ liệu
print("\n[POST CONVERSION]\n Number of numerical columns: {}".format(df.select_dtypes(include=np.number).shape[1]))
print("\n[POST CONVERSION]\n Number of non-numerical columns: {}".format(df.select_dtypes(exclude=np.number).shape[1]))

# Thuật toán Cây quyết định
# tạo bản sao
df_tree = df.copy()

df_tree.drop("Booking_ID", axis=1, inplace=True)
print("- Dropped 'Booking_ID' column")

df_tree.head()

# chuyển sang kiểu str
df_tree['required_car_parking_space'] = df_tree['required_car_parking_space'].astype(str)
df_tree['arrival_month'] = df_tree['arrival_month'].astype(str)
df_tree['repeated_guest'] = df_tree['repeated_guest'].astype(str)
df_tree['no_of_previous_cancellations'] = df_tree['no_of_previous_cancellations'].astype(str)
df_tree['no_of_previous_bookings_not_canceled'] = df_tree['no_of_previous_bookings_not_canceled'].astype(str)
df_tree['no_of_special_requests'] = df_tree['no_of_special_requests'].astype(str)
df_tree['booking_status'] = df_tree['booking_status'].astype(str)
df_tree['no_of_adults'] = df_tree['no_of_adults'].astype(str)
df_tree['no_of_children'] = df_tree['no_of_children'].astype(str)
df_tree['no_of_weekend_nights'] = df_tree['no_of_weekend_nights'].astype(str)
df_tree['no_of_week_nights'] = df_tree['no_of_week_nights'].astype(str)
df_tree['type_of_meal_plan'] = df_tree['type_of_meal_plan'].astype(str)
df_tree['room_type_reserved'] = df_tree['room_type_reserved'].astype(str)
df_tree['lead_time'] = df_tree['lead_time'].astype(str)
df_tree['arrival_year'] = df_tree['arrival_year'].astype(str)
df_tree['arrival_date'] = df_tree['arrival_date'].astype(str)
df_tree['market_segment_type'] = df_tree['market_segment_type'].astype(str)
df_tree['avg_price_per_room'] = df_tree['avg_price_per_room'].astype(str)

#Khai báo vectơ đặc trưng và biến mục tiêu
X = df_tree.drop('booking_status', axis=1)
y = df_tree['booking_status'].values.reshape(-1, 1)

# Check the shape of X and y
print ('X:', X.shape,'\ny:', y.shape)

#Tìm kích thước thử nghiệm tốt nhất
# Array of test size value from 0.2 to 0.3
test_size = np.arange(start=0.2, stop=0.35, step= 0.05)

# Khởi tạo danh sách nơi sẽ lưu trữ điểm của từng kích thước bài kiểm tra
score =[]
for size in test_size:
    X_train1, X_test1, y_train1, y_test1 = train_test_split (X, y, test_size=size, random_state=0)
    DT_Clf = DecisionTreeClassifier (max_depth=3)
    DT_Clf.fit (X_train1, y_train1)
    score.append (DT_Clf.score (X_test1, y_test1))

# Tạo một khung dữ liệu để hiển thị kết quả
r= pd.DataFrame({'Test size': test_size , 'Score': score})
r.sort_values(by = ['Score'], ascending = False, inplace = True)
r.style.highlight_max(color='#acd9a8')
# => test size 0.3 có score lớn nhất

#Tách X và y thành các tập huấn luyện và kiểm tra
X_train1, X_test1, y_train1, y_test1 = train_test_split (X, y, stratify=y, test_size = 0.3, random_state = 0)

# check the shape of X_train, X_test, y_train and y_test
print('X_train shape: ', X_train1.shape)
print('X_test shape: ', X_test1.shape)
print('y_train shape: ', y_train1.shape)
print('y_test shape: ', y_test1.shape)

#Đào tạo mô hình cây quyết định
# Khởi tạo mô hình
DT_model = DecisionTreeClassifier(max_depth=3)

# Lắp mô hình vào tập huấn luyện
DT_model.fit(X_train1, y_train1)

y_pred = DT_model.predict(X_test1) #Dự đoán thử nghiệm X

#Kiểm tra điểm chính xác
print('Model accuracy score: {0:0.4f}'. format(accuracy_score(y_test1, y_pred)))

# in điểm trên tập huấn luyện và tập kiểm tra
print('Training set score: {:.4f}'.format(DT_model.score(X_train1, y_train1)))
print('Test set score: {:.4f}'.format(DT_model.score(X_test1, y_test1)))

# KFold
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.model_selection import KFold
#Xác thực chéo K-Fold
kf = KFold(n_splits=10, shuffle=False)

#Độ chính xác xác thực chéo
# Validation
from sklearn.model_selection import cross_val_predict
from sklearn.model_selection import cross_val_score
# Metrics
from sklearn import metrics
from sklearn.metrics import confusion_matrix, auc, roc_curve
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.metrics import PrecisionRecallDisplay, RocCurveDisplay
from sklearn.metrics import ConfusionMatrixDisplay, classification_report
from statistics import stdev
score = cross_val_score(DT_model, X_train1, y_train1, cv=kf, scoring='accuracy')
DT_model_cv_score = score.mean()
DT_model_cv_stdev = stdev(score)
print('Điểm số Độ chính xác của Xác thực chéo là:\n {}'.format(score))

Accuracy  = ['Độ chính xác xác thực chéo']
DT_A = pd.DataFrame({'CV Mean':DT_model_cv_score,'Std':DT_model_cv_stdev},index=Accuracy )
DT_A
#=>Bằng cách sử dụng xác thực chéo trung bình,  có thể kết luận rằng mong đợi mô hình có độ chính xác trung bình khoảng 77,83 %.

ConfusionMatrixDisplay.from_estimator(DT_model, X_test1, y_test1, colorbar=False, cmap='Greens')
plt.title('Ma trận nhầm lẫn của  Decision Tree')
plt.grid(False)

#Báo cáo phân loại
print(classification_report(y_test1, y_pred))

# Số liệu hiệu suất
def metrics_calculator(y_test, y_pred, model_name):
    '''
    Hàm này tính toán tất cả các chỉ số hiệu suất mong muốn cho một mô hình nhất định.
    '''
    result = pd.DataFrame(data=[accuracy_score(y_test, y_pred),
                                precision_score(y_test, y_pred, average='macro'),
                                recall_score(y_test, y_pred, average='macro'),
                                f1_score(y_test, y_pred, average='macro')],
                          index=['Accuracy','Precision','Recall','F1-score'],
                          columns = [model_name])
    return result

DT_result = metrics_calculator(y_test1, y_pred, 'Decision Tree') #y_pred dự đoán thử nghiệm X
DT_result

feature_names = X.columns
target_names = ["Not_Cancle", "Cancle"]

# vẽ cây quyết định
#
from sklearn.tree import DecisionTreeClassifier
from sklearn import tree
from sklearn import datasets
from IPython.display import Image
from sklearn import model_selection

import pydotplus
#
dot_data = tree.export_graphviz(DT_model, out_file=None,
                                feature_names=feature_names,
                                class_names=target_names)

#
graph = pydotplus.graph_from_dot_data(dot_data)
#
Image(graph.create_png())
# gini = 1-(17073/25392)^2-(8319/25392)^2=0.441
#values =[Not_Cancle, Cancle] => Not_Cancle + Canle = samples: tổng số dl ở nude
# class : nếu Not_Cancle > Cancle -> Not_Cancle.

#đánh giá mức độ ảnh hưởng của các thuộc tính 
import pandas as pd
#
feature_ipm = pd.Series(DT_model.feature_importances_, index=df_tree.columns.values[0:17]).sort_values(ascending=False)
feature_ipm

# Commented out IPython magic to ensure Python compatibility.
from ast import increment_lineno
#
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
#creating a bar plot
sns.barplot(x=feature_ipm , y=feature_ipm.index)
# thêm nhãn cho biểu đồ 
plt.xlabel('Mức quan trọng ')
plt.ylabel('Tính năng')
plt.title('Trực quan hóa các tính năng')
plt.legend()
plt.show()

#RandomForest
# tạo bản copy
df_rf = df.copy()

df_rf.drop("Booking_ID", axis=1, inplace=True)
print("- Dropped 'Booking_ID' column")

df_rf.head()

#xây dựng tập huấn luyện, kiểm thử dữ liệu
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
X = df_rf.drop('booking_status', axis=1)
y = df_rf['booking_status'].ravel()

# Array of test size value from 0.2 to 0.3
test_size = np.arange(start=0.2, stop=0.35, step=0.05)

# Khởi tạo danh sách nơi sẽ lưu trữ điểm của từng kích thước bài kiểm tra
score = []
for size in test_size:
    X_train2, X_test2, y_train2, y_test2 = train_test_split (X, y, test_size=size, random_state=0)
    RF_model = RandomForestClassifier ()
    RF_model.fit (X_train2, y_train2)
    score.append (RF_model.score (X_test2, y_test2))
    
# Tạo một khung dữ liệu để hiển thị kết quả   
r= pd.DataFrame({'Test size': test_size, 'Score': score})
r.sort_values(by = ['Score'], ascending = False, inplace = True)
r.style.highlight_max(color='#acd9a8')
# -> test size = 0.2 có score lớn nhất

# Tách X và y thành các tập huấn luyện và kiểm tra
X_train2, X_test2, y_train2, y_test2 = train_test_split(X, y, stratify=y, test_size = 0.2, random_state = 0)

# kiểm tra  của X_train, X_test, y_train và y_test
print('X_train shape:', X_train2.shape)
print('X_test shape:', X_test2.shape)
print('y_train shape:', y_train2.shape)
print('y_test shape:', y_test2.shape)

# Khởi tạo mô hình
RF_model = RandomForestClassifier()

# Lắp mô hình vào tập huấn luyện
RF_model.fit(X_train2, y_train2)

y_pred = RF_model.predict(X_test2) #y_pred dự đoán thử nghiệm X

print('Model Accuracy Score: {0:0.4f}'. format(accuracy_score(y_test2, y_pred)))

# Scores on training and test set
print('Training set score: {:.4f}'.format(RF_model.score(X_train2, y_train2)))
print('Test set score: {:.4f}'.format(RF_model.score(X_test2, y_test2)))

# KFold
kf = KFold(n_splits=10, shuffle=False)

# độ chính xác của xác thực chéo 
score = cross_val_score(RF_model, X_train2, y_train2, cv=kf, scoring='accuracy')
RF_model_cv_score = score.mean()
RF_model_cv_stdev = stdev(score)
print('Cross Validation Accuracy scores are:\n {}'.format(score))

Accuracy = ['Độ chính xác xác thực chéo']
RF_A = pd.DataFrame({'CV Mean':RF_model_cv_score,'Std':RF_model_cv_stdev},index=Accuracy)
RF_A
#=>Bằng cách sử dụng xác thực chéo trung bình, chúng tôi có thể kết luận rằng chúng tôi mong đợi mô hình có độ chính xác trung bình khoảng 90.03 %.

ConfusionMatrixDisplay.from_estimator(RF_model, X_test2, y_test2, colorbar=False, cmap='Greens')
plt.title('Confusion Matrix of Random Forest')
plt.grid(False)

print(classification_report(y_test2, y_pred))

RF_result = metrics_calculator(y_test2, y_pred, ' Random Forest')
RF_result

# chạy thuật toán RF
result = RF_model.predict([[2,0,0,3,1,0,1,37,2018,10,13,0,0,0,0,105,0]])
if result.all() == 0:
  print("Not Cancel")
else:
    print("Cancel")
# => RF đã đúng

#SVM Model
df_svm = df.copy()

df_svm.drop("Booking_ID", axis=1, inplace=True)
print("- Dropped 'Booking_ID' column")

X = df_svm.drop('booking_status', axis=1)
y = df_svm['booking_status'].ravel()

print ('X:', X.shape,'\ny:', y.shape)

from sklearn import svm
from sklearn.svm import SVC
#Tìm kích thước thử nghiệm tốt nhất
# Mảng giá trị kích thước thử nghiệm từ 0,2 đến 0,3
test_size = np.arange(start=0.2, stop=0.35, step=0.05)

# Khởi tạo danh sách nơi sẽ lưu trữ điểm của từng kích thước bài kiểm tra
score = []
for size in test_size:
    X_train3, X_test3, y_train3, y_test3 = train_test_split (X, y, test_size=size, random_state=0)
    svm_model = svm.SVC()
    svm_model.fit (X_train3, y_train3)
    score.append (svm_model.score (X_test3, y_test3))
    
# Tạo một khung dữ liệu để hiển thị kết quả 
r= pd.DataFrame({'Test size': test_size, 'Score': score})
r.sort_values(by = ['Score'], ascending = False, inplace = True)
r.style.highlight_max(color='#acd9a8')
#=> chọn test size = 0.25

# Tách X và y thành các tập huấn luyện và kiểm tra
X_train3, X_test3, y_train3, y_test3 = train_test_split (X, y, stratify=y, test_size = 0.25 , random_state = 0)

# check the shape of X_train, X_test, y_train and y_test
print('X_train shape:', X_train3.shape)
print('X_test shape:', X_test3.shape)
print('y_train shape:', y_train3.shape)
print('y_test shape:', y_test3.shape)

# Chia tỷ lệ các tính năng bằng StandardScaler
scaler = StandardScaler()

# Khớp bộ chia tỷ lệ với dữ liệu huấn luyện và biến đổi nó
X_train3 = scaler.fit_transform(X_train3)

# Chuyển đổi dữ liệu thử nghiệm bằng cùng một bộ chia tỷ lệ
X_test3 = scaler.transform(X_test3)

# Khởi tạo mô hình
svm_model = svm.SVC(probability=True)

#Lắp mô hình vào tập huấn luyện
svm_model.fit(X_train3, y_train3)

#Dự đoán thử nghiệm X
y_pred = svm_model.predict(X_test3)

#Kiểm tra điểm chính xác
print('Điểm chính xác của mô hình: {0:0.4f}'. format(accuracy_score(y_test3, y_pred)))

#Check for Overfitting and Underfitting
print('Training set score: {:.4f}'.format(svm_model.score(X_train3, y_train3)))
print('Test set score: {:.4f}'.format(svm_model.score(X_test3, y_test3)))

#Xác thực chéo K-Fold
kf = KFold(n_splits=10, shuffle=False)

#Độ chính xác xác thực chéo
score = cross_val_score(svm_model, X_train3, y_train3, cv=kf, scoring='accuracy')
svm_model_cv_score = score.mean()
svm_model_cv_stdev = stdev(score)
print('Điểm số Độ chính xác của Xác thực chéo là:\n {}'.format(score))

Accuracy = ['Độ chính xác xác thực chéo']
svm_A = pd.DataFrame({'CV Mean':svm_model_cv_score,'Std':svm_model_cv_stdev},index=Accuracy)
svm_A
#=> Bằng cách sử dụng xác thực chéo trung bình, chúng tôi có thể kết luận rằng chúng tôi mong đợi mô hình có độ chính xác trung bình khoảng 84.13 %.

ConfusionMatrixDisplay.from_estimator(svm_model, X_test3, y_test3, colorbar=False, cmap='Greens')
plt.title('Confusion Matrix of SVM')
plt.grid(False)

print(classification_report(y_test3, y_pred))

#Số liệu hiệu suất
SVM_result = metrics_calculator(y_test3, y_pred, 'SVM')
SVM_result

#Kích thước kiểm tra được sử dụng cho từng Model
#Decision Tree : test size: 0.3
#Random Forest: 0.2
#SVM : 0.25

#So sánh các chỉ số hiệu suất của các mô hình phân loại
Conclusion = pd.concat([DT_result, RF_result, SVM_result], axis=1)
Conclusion
#Kết luận
# Best Accuracy : Random Forest
# Best Precision: Random Forest
# Best Recall: Random Forest
# Best F1-score : Random Forest

#Ma trận nhầm lẫn so sánh của các mô hình phân loại khác nhau
# Create subplots with 2 rows and 4 columns
fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(16,8))
# Vẽ ma trận nhầm lẫn cho  Decision Tree
ax = axs[0,0]
disp = ConfusionMatrixDisplay.from_estimator(DT_model, X_test1, y_test1, colorbar=False, cmap='Greens', ax=ax)
disp.ax_.set_title('Confusion Matrix of Decision Tree')
disp.ax_.grid(False)
# Vẽ ma trận nhầm lẫn cho Random Forest
ax = axs[0, 1]
disp = ConfusionMatrixDisplay.from_estimator(RF_model, X_test2, y_test2, colorbar=False, cmap='Greens', ax=ax)
disp.ax_.set_title('Confusion Matrix of Random Forest')
disp.ax_.grid(False)
# Plot confusion matrix for SVM
ax = axs[1,0]
disp = ConfusionMatrixDisplay.from_estimator(svm_model, X_test3, y_test3, colorbar=False, cmap='Greens', ax=ax)
disp.ax_.set_title('Confusion Matrix of  SVM')
disp.ax_.grid(False)

# KL:
# Label 0 : Decision Tree > SVM > Random Forest
#Label 1: SVM > Random Forest -> Decision Tree

# tải dữ liệu test
from google.colab import files
uploaded = files.upload()

import io
df_test = pd.read_csv(io.BytesIO(uploaded['dataset_test.csv'])) # đọc dữ liệu

# xem dữ liệu test
rows, col = df_test.shape
print ("Kích thước của tập dữ liệu: {}" . format (df_test.shape))
print ('Rows:', rows, '\nColumns:', col)

#Bỏ các cột dư thừa
# Drop Id column in test data
df_test.drop(['Booking_ID'], axis=1, inplace=True)
df_test.shape

df_test.head()

unique = df_test.nunique()
unique.to_frame().T

#chi tiết thống kê
df_test.iloc[:, :-1].describe().T.sort_values(by='std' , ascending = False)\
                     .style.background_gradient(cmap='Greens')\
                     .bar(subset=["max"], color='#F8766D')\
                     .bar(subset=["mean",], color='#00BFC4')

# Giá trị bị mất(test)
plt.figure(figsize=(22,4))
sns.heatmap((df_test.isna().sum()).to_frame(name='').T,cmap='GnBu', annot=True,
             fmt='0.0f').set_title('Count missing values (test data)', fontsize=18)
plt.show()

# check trùng lập
# Duplicated data (test)
df_test.duplicated().sum()

# Replace values that say "Not selected" in the "type_of_meal_plan" column with 0
df_test["type_of_meal_plan"].replace("Not Selected", 0, inplace=True)
print("- Replaced values that say 'Not selected' in the 'type_of_meal_plan' column with 0")

# Replace values that say "Meal Plan 1" in the "type_of_meal_plan" column with 1
df_test["type_of_meal_plan"].replace("Meal Plan 1", 1, inplace=True)
print("- Replaced values that say 'Meal Plan 1' in the 'type_of_meal_plan' column with 1")

# Replace values that say "Meal Plan 2" in the "type_of_meal_plan" column with 2
df_test["type_of_meal_plan"].replace("Meal Plan 2", 2, inplace=True)
print("- Replaced values that say 'Meal Plan 2' in the 'type_of_meal_plan' column with 2")

# Replace values that say "Meal Plan 3" in the "type_of_meal_plan" column with 3
df_test["type_of_meal_plan"].replace("Meal Plan 3", 3, inplace=True)
print("- Replaced values that say 'Meal Plan 3' in the 'type_of_meal_plan' column with 3")

# Replace values that say "Room_Type 1" in the "room_type_reserved" column with 1
df_test["room_type_reserved"].replace("Room_Type 1", 1, inplace=True)
print("- Replaced values that say 'Room_Type 1' in the 'room_type_reserved' column with 1")

# Replace values that say "Room_Type 2" in the "room_type_reserved" column with 2
df_test["room_type_reserved"].replace("Room_Type 2", 2, inplace=True)
print("- Replaced values that say 'Room_Type 2' in the 'room_type_reserved' column with 2")

# Replace values that say "Room_Type 3" in the "room_type_reserved" column with 3
df_test["room_type_reserved"].replace("Room_Type 3", 3, inplace=True)
print("- Replaced values that say 'Room_Type 3' in the 'room_type_reserved' column with 3")

# Replace values that say "Room_Type 4" in the "room_type_reserved" column with 4
df_test["room_type_reserved"].replace("Room_Type 4", 4, inplace=True)
print("- Replaced values that say 'Room_Type 4' in the 'room_type_reserved' column with 4")

# Replace values that say "Room_Type 5" in the "room_type_reserved" column with 5
df_test["room_type_reserved"].replace("Room_Type 5", 5, inplace=True)
print("- Replaced values that say 'Room_Type 5' in the 'room_type_reserved' column with 5")

# Replace values that say "Room_Type 6" in the "room_type_reserved" column with 6
df_test["room_type_reserved"].replace("Room_Type 6", 6, inplace=True)
print("- Replaced values that say 'Room_Type 6' in the 'room_type_reserved' column with 6")

# Replace values that say "Room_Type 7" in the "room_type_reserved" column with 7
df_test["room_type_reserved"].replace("Room_Type 7", 7, inplace=True)
print("- Replaced values that say 'Room_Type 7' in the 'room_type_reserved' column with 7")

# Replace values that say "Offline" in the "market_segment_type" column with 0
df_test["market_segment_type"].replace("Offline", 0, inplace=True)
print("- Replaced values that say 'Offline' in the 'market_segment_type' column with 0")
# Replace values that say "Online" in the "market_segment_type column with 1
df_test["market_segment_type"].replace("Online", 1, inplace=True)
print("- Replaced values that say 'Online' in the 'market_segment_type' column with 1")
# Replace values that say "Corporate" in the "market_segment_type" column with 2
df_test["market_segment_type"].replace("Corporate", 2, inplace=True)
print("- Replaced values that say 'Corporate' in the 'market_segment_type' column with 2")
# Replace values that say "Aviation" in the "market_segment_type" column with 3
df_test["market_segment_type"].replace("Aviation", 3, inplace=True)
print("- Replaced values that say 'Aviation' in the 'market_segment_type' column with 4")
# Replace values that say "Complementary" in the "market_segment_type" column with 3
df_test["market_segment_type"].replace("Complementary", 4, inplace=True)
print("- Replaced values that say 'Complementary' in the 'market_segment_type' column with 4")

#Dự đoán các mẫu MỚI
df_test.head()

#Mở rộng tính năng trên dữ liệu thử nghiệm
# gán tên cột của DataFrame gốc cho biến cols
cols = df_test.columns

# tạo một phiên bản của StandardScaler
scaler_test = StandardScaler()

# điều chỉnh tỷ lệ phù hợp với dữ liệu thử nghiệm và biến đổi nó
scaled_test = scaler_test.fit_transform(df_test)

# tạo DataFrame từ các tính năng được chia tỷ lệ của tập dữ liệu thử nghiệm
scaled_test = pd.DataFrame(scaled_test, columns=[cols])

scaled_test.head()

#Dự đoán phạm vi hủy hay không
# dự đoán theo mô hình SVM
booking_status =svm_model.predict(scaled_test)

# Create a new dataframe for the predicted price range
booking_status_df = pd.DataFrame({'booking_status': booking_status})
booking_status_df

new_samples = df_test.copy()

# Add booking_status range to new_samples DataFrame
new_samples['booking_status'] = booking_status
new_samples.head(10).style.set_properties(**{'background-color': '#7fc5ba'}, subset=['booking_status'])